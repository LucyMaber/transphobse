import sqlite3
import json

class ArticleDatabase:
    def __init__(self, db_path="articles.db"):
        self.conn = sqlite3.connect(db_path)
        self._create_tables()

    def _create_tables(self):
        """Create the SQL tables if they don't exist."""
        create_articles_table = """
        CREATE TABLE IF NOT EXISTS articles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT UNIQUE,
            score REAL,
            type_page TEXT,
            description TEXT,
            headline TEXT,
            datePublished TEXT,
            dateModified TEXT
        );
        """
        create_keywords_table = """
        CREATE TABLE IF NOT EXISTS keywords (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            keyword TEXT UNIQUE
        );
        """
        create_authors_table = """
        CREATE TABLE IF NOT EXISTS authors (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE
        );
        """
        create_keyphrases_table = """
        CREATE TABLE IF NOT EXISTS keyphrases (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            keyphrase TEXT UNIQUE
        );
        """
        create_article_keywords_table = """
        CREATE TABLE IF NOT EXISTS article_keywords (
            article_id INTEGER,
            keyword_id INTEGER,
            FOREIGN KEY(article_id) REFERENCES articles(id),
            FOREIGN KEY(keyword_id) REFERENCES keywords(id),
            PRIMARY KEY(article_id, keyword_id)
        );
        """
        create_article_authors_table = """
        CREATE TABLE IF NOT EXISTS article_authors (
            article_id INTEGER,
            author_id INTEGER,
            FOREIGN KEY(article_id) REFERENCES articles(id),
            FOREIGN KEY(author_id) REFERENCES authors(id),
            PRIMARY KEY(article_id, author_id)
        );
        """
        create_article_keyphrases_table = """
        CREATE TABLE IF NOT EXISTS article_keyphrases (
            article_id INTEGER,
            keyphrase_id INTEGER,
            FOREIGN KEY(article_id) REFERENCES articles(id),
            FOREIGN KEY(keyphrase_id) REFERENCES keyphrases(id),
            PRIMARY KEY(article_id, keyphrase_id)
        );
        """
        self.conn.execute(create_articles_table)
        self.conn.execute(create_keywords_table)
        self.conn.execute(create_authors_table)
        self.conn.execute(create_keyphrases_table)
        self.conn.execute(create_article_keywords_table)
        self.conn.execute(create_article_authors_table)
        self.conn.execute(create_article_keyphrases_table)
        self.conn.commit()

    def _insert_or_get_id(self, table, field, value):
        """Insert a value into a table if it doesn't exist, and return its ID."""
        query = f"SELECT id FROM {table} WHERE {field} = ?"
        cursor = self.conn.execute(query, (value,))
        row = cursor.fetchone()
        if row:
            return row[0]
        insert_query = f"INSERT INTO {table} ({field}) VALUES (?)"
        cursor = self.conn.execute(insert_query, (value,))
        self.conn.commit()
        return cursor.lastrowid

    def add_article(self, article_data):
        """Insert or update an article entry in the database."""
        insert_article_query = """
        INSERT INTO articles (url, score, type_page, description, headline, datePublished, dateModified)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(url) DO UPDATE SET
            score=excluded.score,
            type_page=excluded.type_page,
            description=excluded.description,
            headline=excluded.headline,
            datePublished=excluded.datePublished,
            dateModified=excluded.dateModified;
        """
        values = (
            article_data["url"],
            article_data["score"],
            article_data["type_page"],
            article_data["description"],
            article_data["headline"],
            article_data["datePublished"],
            article_data["dateModified"]
        )
        self.conn.execute(insert_article_query, values)
        self.conn.commit()

        # Get the article ID
        cursor = self.conn.execute("SELECT id FROM articles WHERE url = ?", (article_data["url"],))
        article_id = cursor.fetchone()[0]

        # Insert keywords
        self._link_many_to_many(article_id, article_data["keywords_found"], "keywords", "keyword", "article_keywords", "keyword_id")

        # Insert authors
        self._link_many_to_many(article_id, article_data["author"], "authors", "name", "article_authors", "author_id")

        # Insert keyphrases
        self._link_many_to_many(article_id, article_data["new_keyphrases"], "keyphrases", "keyphrase", "article_keyphrases", "keyphrase_id")

    def _link_many_to_many(self, article_id, values, table, field, join_table, join_field):
        """Link many-to-many relationships between articles and other entities."""
        for value in values:
            entity_id = self._insert_or_get_id(table, field, value)
            insert_relation_query = f"""
            INSERT OR IGNORE INTO {join_table} (article_id, {join_field})
            VALUES (?, ?)
            """
            self.conn.execute(insert_relation_query, (article_id, entity_id))
        self.conn.commit()

    def get_article(self, url):
        """Fetch an article by its URL, along with related keywords, authors, and keyphrases."""
        select_article_query = "SELECT * FROM articles WHERE url = ?"
        cursor = self.conn.execute(select_article_query, (url,))
        row = cursor.fetchone()
        if row:
            article = {
                "id": row[0],
                "url": row[1],
                "score": row[2],
                "type_page": row[3],
                "description": row[4],
                "headline": row[5],
                "datePublished": row[6],
                "dateModified": row[7],
                "keywords_found": self._get_related_data(row[0], "keywords", "article_keywords", "keyword"),
                "author": self._get_related_data(row[0], "authors", "article_authors", "name"),
                "new_keyphrases": self._get_related_data(row[0], "keyphrases", "article_keyphrases", "keyphrase")
            }
            return article
        return None

    def _get_related_data(self, article_id, table, join_table, field):
        """Fetch related data (keywords, authors, or keyphrases) for a given article."""
        query = f"""
        SELECT {table}.{field} FROM {table}
        JOIN {join_table} ON {table}.id = {join_table}.{field}_id
        WHERE {join_table}.article_id = ?
        """
        cursor = self.conn.execute(query, (article_id,))
        return [row[0] for row in cursor.fetchall()]

    def delete_article(self, url):
        """Delete an article by its URL."""
        delete_query = "DELETE FROM articles WHERE url = ?"
        self.conn.execute(delete_query, (url,))
        self.conn.commit()

    def list_articles(self):
        """List all articles in the database."""
        select_query = "SELECT url, headline, score FROM articles"
        cursor = self.conn.execute(select_query)
        return cursor.fetchall()

    def clear(self):
        """Clear the articles table."""
        self.conn.execute("DELETE FROM articles")
        self.conn.commit()

    # Dictionary-like methods
    def __getitem__(self, url):
        """Get an article by its URL."""
        return self.get_article(url)

    def __setitem__(self, url, article_data):
        """Set an article by its URL."""
        article_data["url"] = url
        self.add_article(article_data)

    def __delitem__(self, url):
        """Delete an article by its URL."""
        self.delete_article(url)

    def __contains__(self, url):
        """Check if an article exists by its URL."""
        return self.get_article(url) is not None

    def __len__(self):
        """Return the number of articles in the database."""
        cursor = self.conn.execute("SELECT COUNT(*) FROM articles")
        return cursor.fetchone()[0]

    def __iter__(self):
        """Iterate over all URLs in the database."""
        cursor = self.conn.execute("SELECT url FROM articles")
        for row in cursor:
            yield row[0]

    def keys(self):
        """Return all URLs in the database."""
        cursor = self.conn.execute("SELECT url FROM articles")
        return [row[0] for row in cursor.fetchall()]

    def values(self):
        """Return all articles in the database."""
        cursor = self.conn.execute("SELECT * FROM articles")
        return [self._row_to_dict(row) for row in cursor.fetchall()]

    def items(self):
        """Return all articles as (URL, article) pairs."""
        cursor = self.conn.execute("SELECT * FROM articles")
        return [(row[1], self._row_to_dict(row)) for row in cursor.fetchall()]

    def get(self, url, default=None):
        """Get an article by its URL, or return default."""
        return self.get_article(url) or default

    def pop(self, url, default=None):
        """Pop an article by its URL, or return default."""
        article = self.get_article(url)
        if article:
            self.delete_article(url)
            return article
        return default

    def update(self, other):
        """Update the database with articles from another dictionary."""
        for url, article_data in other.items():
            self[url] = article_data

    def fromkeys(self, urls, value=None):
        """Create a dictionary with URLs as keys and the same value for all."""
        return {url: self.get(url, value) for url in urls}

    def copy(self):
        """Return a shallow copy of the database as a dictionary."""
        return dict(self.items())

    def __del__(self):
        """Close the database connection."""
        self.conn.close()

    def _row_to_dict(self, row):
        """Convert a row to a dictionary."""
        return {
            "id": row[0],
            "url": row[1],
            "score": row[2],
            "type_page": row[3],
            "description": row[4],
            "headline": row[5],
            "datePublished": row[6],
            "dateModified": row[7],
            "keywords_found": self._get_related_data(row[0], "keywords", "article_keywords", "keyword"),
            "author": self._get_related_data(row[0], "authors", "article_authors", "name"),
            "new_keyphrases": self._get_related_data(row[0], "keyphrases", "article_keyphrases", "keyphrase")
        }
